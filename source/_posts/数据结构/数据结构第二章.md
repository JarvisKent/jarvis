title: 第二章:算法
date: 2016-08-18 17:52:58
categories: [数据结构]
tags: [算法]
---
![算法配图](http://obl32g9cf.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E9%85%8D%E5%9B%BE.jpeg)
你所浪费的今天是昨天死去的人所期望的明天、你所厌恶的现在是未来的你回不去的曾经。<!--more -->

# 一、算法的定义

>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

# 二、算法的特性

算法具有5个基本特性：输入、输出、有穷性、确定性和可行性。

## 1、输入输出

算法具有零个或多个输入，至少有一个或多个输出。

## 2、有穷性

指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。

## 3、确定性

算法的每一步骤都具有确定的含义，不会出现二义性。

## 4、可行性

算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

# 三、算法设计的要求

## 1、正确性

- 算法程序没有语法错误。
- 算法程序对于合法的输入数据能够产生满足要求的输出结果。
- 算法程序对于非法的输入数据能够得出满足规格的结果。
- 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。

## 2、可读性

算法设计的另一目的是为了便于阅读，理解和交流。

## 3、健壮性

当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

## 4、时间效率高和存储量低

# 四、算法效率的度量方法

## 1、事后统计的方法

>主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法的编制的程序的运行时间进行比较，从而确定算法效率的高低。

这种方法有如下缺陷:
- 必须依据算法事先编好程序。
- 依赖硬件和软件等环境因素。
- 测试数据设计困难，程序运行时间也往往与测试数据规模有很大关系。

## 2、事前分析估算

>在计算机程序编制前，依据统计方法对算法进行估算。

一个高级语言编写的程序在计算机上运行时所消耗的时间取决于:
- 算法采用的策略、方法。
- 编译产生的代码质量。
- 问题的输入规模。
- 机器执行指令的速度。

# 五、函数的渐近增长
>给定两个函数f(x)和g(x)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。

- 第一个例子
![例子1](http://obl32g9cf.bkt.clouddn.com/%E7%AE%97%E6%B3%951.jpg)

 当随着n的增加，可以看出算法A与算法B中后面所加的常数对算法变化几乎没影响，所以我们可以忽略这些加法常数。
- 第二个例子
![例子2](http://obl32g9cf.bkt.clouddn.com/%E7%AE%97%E6%B3%952.jpg)


 从上图可以看出当n<=3时，算法C差于算法D（C次数比较多），而n>3时，算法C明显越来越优于算法D了。所以，可以看出算法的优劣*与最高次项相乘的常数并不重要。*

- 第三个例子
![例子3](http://obl32g9cf.bkt.clouddn.com/%E7%AE%97%E6%B3%953.jpg)

 而*最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快。*

- 第四个例子
![例子4](http://obl32g9cf.bkt.clouddn.com/%E7%AE%97%E6%B3%954.jpg)


 可以得出*判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而应该关注主项（最高阶项）的阶数。*

某个算法，随着n的增大，会越来越优于另一算法或差于另一个算法其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。

# 六、算法时间复杂度

>在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间量度。记作：T（n）=O（f（n））。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f（n）是问题规模n的某个函数。

这样用大写O（）来体现算法时间复杂度的记法，称之为大O记法。一般情况下，随着n的增大，T（n）增长越慢的算法为最优算法。

## 1、推导大O阶方法

```
1、用常数1取代运行时间中的所有加法常数。
2、在修改后的运行次数函数中，只保留最高阶项。
3、如果最高阶项存在且不是1，则去除与这个项相乘的常数。
得到的结果就是大O阶
```

- 常数阶

```
int sum = 0; n = 100;        //执行一次
sum = (1 + n) * n / 2;        //执行一次
printf("%d",sum);            //执行一次
```
从上面代码可以看出执行次数f(n) = 3；根据大O阶推导的方法，第一步就是常数用1取代，所以这个算法的时间复杂度为O(1)。

- 线性阶

```
int i;
for(i = 0; i< n; i++){
    //时间复杂度为O(1)的程序步骤序列
}
```

分析算法的复杂度，关键就是要分析循环结构的运行情况。如上面的代码复杂度为O（n），因为循环体中代码要执行n次。

- 对数阶

```
int count = 1;
while(count < n){
count = count * 2;        //时间复杂度为O（1）的程序步骤序列
}
```

这个算法其实是计算多少个2相乘后大于n，则循环退出。由$2^{X} = n$得到 X=$log:n$;所以这个算法的时间复杂度是O（$log:n$）。

- 平方阶

1、
```
int  i, j;
for(i = 0 ; i < n ; i++){
    for(j = 0 ; j＜n; j++){
            //执行时间复杂度为O（1）的程序步骤序列
   }
}
```

上面算法是时间复杂度为O（n）的语句，再循环n次，所以它的时间复杂度为O（$n^{2}$）。

2、
```
int i,j;
for(i = 0; i<m;i++){
    for(j=0;j<n;j++){
       //时间复杂度为O（1）的程序步骤序列 
   }
}
```
上面算法时间复杂度为O（m*n）。由此可以得出循环体的时间复杂度等于循环体的复杂度乘以该循环的运行次数。

３、
```
int i,j;
for(i = 0; i<n;i++){
    for(j=i;j<n;j++){
        //时间复杂度为O（1）的程序步骤序列。
   }
}
```
执行的总次数为n+(n-1)+…+1=$\frac{n(n+1)}{2}$=$\frac{n^{2}}{2}+\frac{n}{2}$。根据推导方法（去除加减法常数，保留最高阶项，去除这个项相乘的常数）可得到时间复杂度为O（n^{2}）。

# 常见的时间复杂度


| 执行次数函数|阶|非正式术语|
| -----|:----:| :----:| 
| 12|O（1）   |  常数阶   |
| 2n+3| O（n）   | 线性阶   | 
| 3$n^{2}$+2n+1  | O（$n^{2}$）   | 平方阶   | 
| 5$log:n$+20 | O（$log:n$）  | 对数阶   | 
| 2n+3n$log:n$+19| O（n$log:n$）  | n$log:n$阶   | 
| 6$n^{3}$+2$n^{2}$+4  | O（$n^{3}$）   | 立方阶   | 
| $2^{n}$  | O（$2^{n}$）   | 指数阶   | 

常见的时间复杂度所消费的时间从小到大依次是：
O（1）<O（$log:n$）<O（n）<O（n$log:n$）<O（$n^{2}$）<O（$n^{3}$）<O（$2^{n}$）<O（n!）<O（$n^{n}$）

## 最坏情况与平均情况

最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。

平均情况运行时间是最有意义的，因为它是期望的运行时间。

# 七、算法空间复杂度

>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S（n） = O（f（n）），其中，n为问题规模，f（n）为语句相关n所占存储空间的函数。
